### onCreate和onRestoreInstanceState方法的其区别
> onRestoreInstanceState里的Bundle不会为空，onCreate里的Bundle有可能为空

### 7个生命周期
1. onCreate
2. onStart
3. onResume
4. onPause
5. onStop
6. onDestroy
7. onReStart


### Activity之间的通信
* Intent/Bundle
* 类静态变量
* 全局变量

### Activit将数据传递发给Fragment
* Bundle
* 直接在Activity中定义方法

### Fragment传数据给Activity
1. 在Fragent中定义内部接口
2. 在Fragment的onAttach方法中实现回调
3. 调用onDetach把传进来的对象销毁掉


### Activity与Service的数据通信
* 绑定服务，利用onServiceConnection类
* 简单通信，利用Intent进行传值
* 定义一个callback接口来监听服务中的进程的变化

### Android启动模式
* standard
> 每启动一个Activity都会创建一个新的实例，onCreate、onStart、onResume都会走
* singleTop
> 实例位于栈顶时复用，回调onNewIntent方法。应用：即时通信对话框、新闻推送
* singleInstance
> 回调onNewIntent。应用：主界面
1. 首先会根据taskAffinity去寻找当前是否存在一个对应名字的任务栈
2. 不能存在则创建一个新的task
3. 若存在，得到任务栈，在该任务栈中查找是否存在对应activity实例
* singleTask
> 具有全局唯一性（整个系统中只有一个实例）；具有独占性（任务栈只有一个实例）

## Service
#### Service和Thread的区别和应用场景
* Thread：程序执行的最小单元，分配CPU的基本单位

##### Thread的生命周期
1. 新建
2. 就绪
3. 运行
4. 死亡
5. 阻塞

**Thread的致命缺点**：无法控制

##### Service的生命周期
1. onCreate
2. onStartCommand
3. onBind
4. onUnbind
5. onDestroy

### Serializable
> 1. Java的接口
> 2. 实现简单，内存开销大

### Parcelable
> 1. Android的接口
> 2. 实现复杂，内存开销小

**内存间传递数据用Parcelable，写到磁盘用Serializable**

## 广播的静态注册和动态注册
* 静态注册
> 在AndroidManifest.xml中通过\<receiver\>标签声明<br>常驻进程中，不受组件生命周期影响<br>应用场景：需要时刻监听广播
* 动态注册
> 在代码中调用Context.registereceiver<br>跟随组件的生命周期变化<br>应用场景：需要在特定时刻接收广播
